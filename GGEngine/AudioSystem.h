#pragma once
#include <fmod.hpp>
#include <fmod_studio.hpp>
#include <fmod_errors.h>
#include "Tools.h"
#include "Serializable.h"
#include "Vector.h"

// Reference : http://www.fmod.org/questions/question/forum-24840/
#define FMOD_DISTANCEFACTOR	1.f								// Units per meter. i.e. centimeters would be 100
#define FMOD_MIN_DISTANCE	10.f							// Determine if the sound is soft or loud in 3D Space
#define FMOD_MAX_DISTANCE	100.f							// Distance a sound stops attenuating at

enum class AUDIOTYPE { NONE, BGM, SFX, LSFX, TEST };

// Audio Information (for Initializing purpose)
struct AudioInfo : public Serializable
{
	std::string filename;		// Relative path of where is the audio located
	float volume;				// Volume to be played
	bool audio_3d;				// Determine if the audio is to be 3D
	FMOD_VECTOR pos;			// Current position of the audio in the coordinate space
	float deg_spread;			// The current spread of the 3D audio

	AudioInfo()
		: filename{ }, volume{ 0 }, audio_3d{ true }, pos{ 0,0,0 },
		deg_spread{ 180.f }
	{
		AddSerializable("File_Name", filename);
		AddSerializable("Volume", volume);
		AddSerializable("Audio3D", audio_3d);
		AddSerializable("Spread3D", deg_spread, "3D Spread determines how \"spread out\" the audio should be. Value of 0 or 360 makes the audio Mono.");
	}

	AudioInfo(const AudioInfo& ai) :
		filename{ ai.filename }, volume{ ai.volume }, audio_3d{ ai.audio_3d },
		pos{ ai.pos }, deg_spread{ ai.deg_spread }

	{
		AddSerializable("File_Name", filename);
		AddSerializable("Volume", volume);
		AddSerializable("Audio3D", audio_3d);
		AddSerializable("Spread3D", deg_spread, "3D Spread determines how \"spread out\" the audio should be. Value of 0 or 360 makes the audio Mono.");
		UpdateSerializables();
	}

	AudioInfo(const std::string& _filename, float _volume = 1.f, bool _audio_3d = false, float _deg_spread = 180.f, const FMOD_VECTOR& _pos = { 0,0,0 })
		: filename{ _filename }, volume{ _volume }, audio_3d{ _audio_3d }, pos{ _pos }, deg_spread{ _deg_spread }
	{
		AddSerializable("File_Name", filename);
		AddSerializable("Volume", volume);
		AddSerializable("Audio3D", audio_3d);
		AddSerializable("Spread3D", deg_spread, "3D Spread determines how \"spread out\" the audio should be. Value of 0 or 360 makes the audio Mono.");
	}
	void TestSound(unsigned fade_out_sec = 0);
	void StopTestSound();
	bool operator!=(const AudioInfo&) const
	{
		return true;
	}
	bool operator==(const AudioInfo&) const
	{
		return false;
	}
};

namespace
{
	// FMOD ERROR CHECKING
	void FMODErrorCheck(FMOD_RESULT result)
	{
		if (result != FMOD_OK)
			// Swapped out for Assertion since it will crash here either way
			TOOLS::Assert(false, "FMOD error! - ", FMOD_ErrorString(result));
	}
}

// Contains the information of a particular audio that is generated by FMOD
struct AudioFile
{
	FMOD::Sound* sound;			// pointer to the current audio
	FMOD::Channel* channel;		// current channel that the audio is in
	std::string filename;		// audio filename
	std::string relative_path;	// audio's relative path + filename
	bool fading;				// determine if the current audio is doing a fading
	bool stop_aud_fade;			// Stopping the audio after fade
	AUDIOTYPE type;				// determine if this audio is BGM, SFX LSFX, or Test type
	float volume;				// Volume of the audio file
	FMOD_VECTOR last_pos;		// last position of the sound position in FMOD space
	FMOD_VECTOR audio_pos;		// current position of the sound in FMOD space
	FMOD_VECTOR velocity;		// velocity of the "movement" sound
	float spread;				// Determine how spread out the audio should be (in degrees)
	unsigned fading_points;		// number of fading points available
	unsigned fade_time;			// The fade out time interval
	bool three_d_audio;			// determine if the audio is 3D
	std::vector<unsigned long long> point_dspclock;
	std::vector<float> point_volume;

	AudioFile()
		: sound{ nullptr }, channel{ nullptr },
		fading_points{ 0 }, stop_aud_fade{ false }, last_pos{ 0,0,0 },
		audio_pos{ 0, 0, 0 }, velocity{ 0,0,0 },
		three_d_audio{ true }, spread{ 180.f }, volume{ 1.f },
		fade_time{ 0 }
	{ }

	bool operator==(const AudioFile& rhs) const { return std::tie(channel, filename) == std::tie(rhs.channel, rhs.filename); }
	bool operator!=(const AudioFile& rhs) const { return !operator==(rhs); }
	friend std::ostream& operator<<(std::ostream& os, const AudioFile& aud_file) { return os << "Audio's Filename: " << aud_file.filename; }
	void SetPaused(bool pause) { return FMODErrorCheck(channel->setPaused(pause)); }
	bool GetPaused() const
	{
		bool paused = false;
		FMODErrorCheck(channel->getPaused(&paused));
		return paused;
	}
	void SetVolume(float vol) { return FMODErrorCheck(channel->setVolume(volume = vol)); }
	inline float GetVolume() const { return volume; }
	// Refer to this website: https://www.fmod.com/docs/api/content/generated/FMOD_MODE.html
	void SetMode(FMOD_MODE mode)
	{
		if (channel)
			channel->setMode(mode);
	}
	FMOD_MODE GetMode() const
	{
		FMOD_MODE mode = FMOD_DEFAULT;
		if (channel)
			channel->getMode(&mode);
		return mode;
	}
};

namespace
{
	// Categorized Channels i.e. BGM, SFX, LSFX
	struct AudioChannelInfo
	{
		std::map<std::string, AudioFile> map;
		std::vector<FMOD::Sound*> sounds;
		FMOD::ChannelGroup* channel_group;
		bool to_pause;

		// FMOD::Studio Section

		unsigned fading_points;
		std::vector<unsigned long long> point_dspclock;
		std::vector<float> point_volume;
		bool fading;

		AudioChannelInfo()
			: channel_group{ nullptr },
			fading{ false }, to_pause{ false }, fading_points{ 0 }
		{ }

		void SetPaused(bool pause) { return FMODErrorCheck(channel_group->setPaused(pause)); }
		bool GetPaused() const
		{
			bool paused = false;
			FMODErrorCheck(channel_group->getPaused(&paused));
			return paused;
		}
		void SetVolume(float volume) { return FMODErrorCheck(channel_group->setVolume(volume)); }
		float GetVolume() const
		{
			float volume = 0;
			FMODErrorCheck(channel_group->getVolume(&volume));
			return volume;
		}
	};

}

class AudioSystem final : public CoreSystem
{
	friend class CoreEngine;

	FMOD::System* system;
	FMOD::Studio::System* studio_system;
	FMOD_RESULT result;
	int channels_playing;
	bool playing, pause_all;
	std::vector<AudioFile*> all_files;				// All available files

	// FMOD 3D
	FMOD_VECTOR forward_vec;						// Listener's foward vector
	FMOD_VECTOR up_vec;								// Listener's Up vector
	FMOD_VECTOR velocity;							// Velocity of which each sound is "moving"
	FMOD_VECTOR listener_pos;						// Audio system's location for the listener
	FMOD_VECTOR last_pos;							// Last position of the vector

	// Information for SFX, LSFX, BGM, Test
	AudioChannelInfo bgm, sfx, lsfx, dialogues, tests;
	FMOD::ChannelGroup* master_group;				// The master groups for all of the sub channel groups

	// Parenting
	AudioSystem *child, *parent;

	// FMOD::STUDIO - Fading
	unsigned long long dsp_clock;
	int audio_rate;
	std::vector<AudioFile*> vec_fading_auds;
	void StaleAudio(AudioFile& aud_file);
	void ClearAllFadingAudios();

	bool CheckVersion();
	AudioFile* RetrieveAudioFile(const std::string& filename);
	AudioFile* RetrieveAudioFile(FMOD::Sound *sound, FMOD::ChannelGroup* chn_group);

public:
	AudioSystem();
	~AudioSystem();
	AudioSystem* GetChild();
	void SetChild(AudioSystem* child);
	AudioFile* GetCurrentBGM() const;
	void Init(bool secondary = false);
	void Update();
	void Unload();
	bool IsAudioPlaying(const AudioFile& aud_file) const;
	void SetMasterVolume(float);
	void SetBGMVolume(float);
	void SetSFXVolume(float);
	void SetLSFXVolume(float);
	float GetMasterVolume() const;
	float GetBGMVolume() const;
	float GetSFXVolume() const;
	float GetLSFXVolume() const;
	// Set's the listener's position (would be either the camera's positon or player's position)
	void SetListenerPosition(const FMOD_VECTOR& vec3);
	// Get the listener's position
	inline FMOD_VECTOR GetListenerPosition() const
	{
		return listener_pos;
	}
	// Update the audio's vector position (passing in the filename string)
	bool SetAudioPosition(const std::string& filename, AUDIOTYPE type, const FMOD_VECTOR& vec3);
	// Update the audio's vector position (passing in the AudioFile type)
	bool SetAudioPosition(AudioFile& audio_file, const FMOD_VECTOR& vec3);
	// Update the audio's volume (passing in the filename string)
	bool SetAudioVolume(const std::string& filename, AUDIOTYPE type, float volume = 1.f);
	// Update the audio's volume (passing in the AudioFile type)
	bool SetAudioVolume(AudioFile& audio_file, float volume = 1.f);
	// Check if the specified audio file passed in is supported by the system
	bool CheckFileSupported(const std::string& filename);
	// Reverses the audio by adjusting the frequency
	void ReverseAudio(const std::string& filename);
	// Reverses the audio by adjusting the frequency (passing in the AudioFile type)
	void ReverseAudio(AudioFile& audio_file);

	/*
		"Test-Play" plays a file
		pause_all is an optional boolean - when toggled to true, it will
		pause all BGM, SFX and LSFX currently playing
	*/
	AudioFile* TestSound(const std::string& filename, float volume = 1.f, unsigned fade_out_sec = 0, bool pause_all = false);
	/*
		Stops the sound if its playing.
		It also removes the sound from the system and resume all sounds if pause_all
		was previously set to true
	*/
	void StopTestSound(const AudioFile* aud_file);
	/*
		Search for a particular sound in the Audio Library and return the respective audio file
		Prevents any modification to the existing sound (hence its const).

		Input: filename of the audio file OR relative path of the audio file
	*/
	const AudioFile* GetAudio(const std::string&, AUDIOTYPE type = AUDIOTYPE::NONE) const;
	// Allows storage of ALL audio found in /Audio folder
	bool StoreAllAudio(const std::string& relative_path);

	/* =========================================
		Pausing, Resuming, Playing & Stopping
	============================================ */

	// Pause any current BGM playing
	void PauseBGM(bool fade_out = false);
	// Pause ALL of SFXs playing
	void PauseSFX();
	// Pause ALL of LSFXs playing
	void PauseLSFX();
	// Pause ALL of Tests playing
	void PauseTests();
	// Pause ALL BGM, SFX, LSFX playing
	void PauseAll();
	/*
		Pause on a certain audio.
		Will return true if the audio has successfully been paused,
		false to indicate that the audio isn't found
	*/
	bool PauseAudio(const std::string& audio_filename);
	/*
		Pause on a certain audio (passing in the AudioFile)
		Will return true if the audio has successfully been paused,
		false to indicate that the audio isn't found
	*/
	bool PauseAudio(AudioFile& aud_file);
	// Resume the BGM that was previously paused
	void ResumeBGM(bool fade_in = false);
	// Resume ALL of the SFX that were previously paused
	void ResumeSFX();
	// Resume ALL of the LSFX that were previously paused
	void ResumeLSFX();
	// Resume ALL of Tests that were previously paused
	void ResumeTests();
	// Resume ALL BGM, SFX, LSFX that were previously passed
	void ResumeAll();
	/*
		Resume on a certain audio.
		Will return true if the audio has been successfully unpaused,
		false to indicate that the audio isn't found
	*/
	bool ResumeAudio(const std::string& audio_filename);
	bool ResumeAudio(AudioFile& aud_file);
	// Play a SFX sound
	AudioFile* PlaySFX(const std::string &);
	// Play a LSFX sound
	AudioFile* PlayLSFX(const std::string &);
	// Play a BGM sound
	AudioFile* PlayBGM(const std::string &);
	// Stop all SFXs
	void StopAllSFX();
	// Stop all LSFXs
	void StopAllLSFX();
	// Stop all BGMs
	void StopAllBGM();
	// Stop ALL of Tests playing (and remove them from the channels)
	void StopTests();
	// Stop a current audio playing in fmod
	void StopAudio(const std::string& filename);
	// Stop a current audio playing in fmod (passing in the AudioFile)
	void StopAudio(AudioFile& audio_file);

	/* ========================
		Adding & Clearing
	======================== */

	// Clear all SFXs in the channels
	void ClearAllSFX();
	// Clears all LSFXs in the channels
	void ClearAllLSFX();
	// Clear all BGMs in the channels
	void ClearAllBGM();
	// Clear all Testing sounds in the channels
	void ClearAllTestSounds();
	// Captures all SFXs
	void AddNewSFX(const std::vector<AudioInfo> &);
	// Captures all LSFXs
	void AddNewLSFX(const std::vector<AudioInfo> &);
	// Captures all BGMs
	void AddNewBGM(const std::vector<AudioInfo> &);
	// Add a new audio into BGM
	void AddNewBGM(const AudioInfo& audio_info);
	// Add a new audio into SFX
	void AddNewSFX(const AudioInfo& audio_info);
	// Add a new audio into LSFX
	void AddNewLSFX(const AudioInfo& audio_info);
	// Remove an audio from the system
	void RemoveAudio(const AudioFile* aud_file);

	/* ==========================
		Fading Audio(s)
	========================== */

	/*
		Fade in an audio (could be used in conjunction with some other functions)
		Fades in for n seconds to the specified volume
	*/
	bool FadeInAudio(AudioFile* aud_file, unsigned seconds, float volume = 1.f);
	/*
		Fades out an audio (could be used in conjunction with some other functions)
		Fades out for n seconds and if stop_aud is true, it will stop the audio after fade out
	*/
	bool FadeOutAudio(AudioFile* aud_file, unsigned seconds, bool stop_aud = true);
};